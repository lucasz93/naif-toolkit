
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dski02</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dski02</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
 DSKI02 ( DSK, fetch integer type 2 data )
 
      SUBROUTINE DSKI02 ( HANDLE, DLADSC, ITEM, START, ROOM, N, VALUES )
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Fetch integer data from a type 2 DSK segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/das.html">DAS</a>
     <a href="../req/dsk.html">DSK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     DAS
     DSK
     FILES
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
      IMPLICIT NONE

      INCLUDE 'dla.inc'
      INCLUDE 'dskdsc.inc'
      INCLUDE 'dsk02.inc'

      INTEGER               HANDLE
      INTEGER               DLADSC ( * )
      INTEGER               ITEM
      INTEGER               START
      INTEGER               ROOM
      INTEGER               N
      INTEGER               VALUES ( * )
      
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Description
     --------  ---  --------------------------------------------------
     HANDLE     I   DSK file handle.
     DLADSC     I   DLA descriptor.
     ITEM       I   Keyword identifying item to fetch.
     START      I   Start index.
     ROOM       I   Amount of room in output array.
     N          O   Number of values returned.
     VALUES     O   Array containing requested item.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     HANDLE         is the handle of a DSK file containing a type 2
                    segment from which data are to be fetched.

     DLADSC         is the DLA descriptor associated with the segment
                    from which data are to be fetched. 

     ITEM           is an integer &quot;keyword&quot; parameter designating the
                    item to fetch. In the descriptions below, note
                    that &quot;model&quot; refers to the model represented by
                    the designated segment.  This model may be a
                    subset of a larger model.

                    Names and meanings of parameters supported by this 
                    routine are:

                       KWNV       Number of vertices in model.

                       KWNP       Number of plates in model.

                       KWNVXT     Total number of voxels in fine grid.

                       KWVGRX     Voxel grid extent.  This extent is
                                  an array of three integers
                                  indicating the number of voxels in
                                  the X, Y, and Z directions in the
                                  fine voxel grid.

                       KWCGSC     Coarse voxel grid scale.  The extent
                                  of the fine voxel grid is related to
                                  the extent of the coarse voxel grid
                                  by this scale factor.

                       KWVXPS     Size of the voxel-to-plate pointer
                                  list. 

                       KWVXLS     Voxel-plate correspondence list size.

                       KWVTLS     Vertex-plate correspondence list
                                  size.

                       KWPLAT     Plate array.  For each plate, this
                                  array contains the indices of the
                                  plate's three vertices.  The ordering
                                  of the array members is:

                                     Plate 1 vertex index 1
                                     Plate 1 vertex index 2
                                     Plate 1 vertex index 3
                                     Plate 2 vertex index 1
                                             ...

                       KWVXPT     Voxel-plate pointer list. This list
                                  contains pointers that map fine
                                  voxels to lists of plates that
                                  intersect those voxels. Note that
                                  only fine voxels belonging to
                                  non-empty coarse voxels are in the
                                  domain of this mapping.

                       KWVXPL     Voxel-plate correspondence list.
                                  This list contains lists of plates
                                  that intersect fine voxels. (This
                                  list is the data structure into
                                  which the voxel-to-plate pointers
                                  point.)  This list can contain
                                  empty lists.
                                                                   
                       KWVTPT     Vertex-plate pointer list. This list
                                  contains pointers that map vertices
                                  to lists of plates to which those
                                  vertices belong.

                                  Note that the size of this list is
                                  always NV, the number of vertices.
                                  Hence there's no need for a separate
                                  keyword for the size of this list.

                       KWVTPL     Vertex-plate correspondence list.
                                  This list contains, for each vertex,
                                  the indices of the plates to which
                                  that vertex belongs.

                       KWCGPT     Coarse voxel grid pointers.  This is
                                  an array of pointers mapping coarse
                                  voxels to lists of pointers in the
                                  voxel-plate pointer list.  Each 
                                  non-empty coarse voxel maps to a
                                  list of pointers; every fine voxel
                                  contained in a non-empty coarse voxel
                                  has its own pointers. Grid elements
                                  corresponding to empty coarse voxels
                                  have null (non-positive) pointers.

                    See the INCLUDE file dsk.inc for values
                    associated with the keyword parameters.


     START          is the start index within the specified data item
                    from which data are to be fetched. The index of
                    the first element of each data item is 1. START
                    has units of integers; for example, the start
                    index of the second plate is 4, since each plate
                    occupies three integers.

     ROOM           is the amount of room in the output array. It is
                    permissible to provide an output array that has
                    too little room to fetch an item in one call. ROOM
                    has units of integers: for example, the room
                    required to fetch one plate is 3.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     N              is the number of elements fetched to the output
                    array VALUES.  N is normally in the range 
                    1:ROOM; if an error occurs on the call, N is
                    undefined.

     VALUES         is a contiguous set of elements of the item
                    designated by ITEM.  The correspondence of 
                    VALUES at the elements of the data item is:

                       VALUES(1)      ITEM(START)
                         ...             ...
                       VALUES(N)      ITEM(START+N-1)
                    
                    If an error occurs on the call, VALUES is 
                    undefined.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     See the INCLUDE files 

         dla.inc
         dsk02.inc
         dskdsc.inc
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1) If the input handle is invalid, the error will be diagnosed by
        routines in the call tree of this routine. 

     2) If a file read error occurs, the error will be diagnosed by
        routines in the call tree of this routine.

     3) If the input DLA descriptor is invalid, the effect of this
        routine is undefined. The error *may* be diagnosed by routines
        in the call tree of this routine, but there are no
        guarantees.

     4) If ROOM is non-positive, the error SPICE(VALUEOUTOFRANGE)
        is signaled.

     5) If the coarse voxel scale read from the designated segment
        is less than 1, the error SPICE(VALUEOUTOFRANGE) is signaled.

     6) If the input keyword parameter is not recognized, the error
        SPICE(NOTSUPPORTED) is signaled.

     7) If START is less than 1 or greater than the size of the
        item to be fetched, the error SPICE(INDEXOUTOFRANGE) is
        signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     See input argument HANDLE.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     Most SPICE applications will not need to call this routine. The
     routines <a href="dskv02.html">DSKV02</a>, <a href="dskp02.html">DSKP02</a>, and <a href="dskz02.html">DSKZ02</a> provide a higher-level
     interface for fetching DSK type 2 vertex and plate data.

     DSK files are built using the DLA low-level format and
     the DAS architecture; DLA files are a specialized type of DAS
     file in which data are organized as a doubly linked list of
     segments.  Each segment's data belong to contiguous components of
     character, double precision, and integer type.

     Note that the DSK descriptor for the segment is not needed by
     this routine; the DLA descriptor contains the base address and
     size information for the integer, double precision, and character
     components of the segment, and these suffice for the purpose of
     fetching data.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for this example may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine 
     specific arithmetic implementation. 
 
     1) Look up all the vertices associated with each plate
        of the model contained in a specified type 2 segment.
        For this example, we'll show the context of this look-up:
        opening the DSK file for read access, traversing a trivial,
        one-segment list to obtain the segment of interest.


        Example code begins here.


                 PROGRAM EX1 
                 IMPLICIT NONE

                 INCLUDE 'dla.inc'
                 INCLUDE 'dskdsc.inc'
                 INCLUDE 'dsk02.inc'

           C
           C     Local parameters
           C 
                 CHARACTER*(*)         FMT
                 PARAMETER           ( FMT    = '(1X,A,3(1XE16.9))' )

                 INTEGER               FILSIZ
                 PARAMETER           ( FILSIZ = 255 )

           C
           C     Local variables
           C 
                 CHARACTER*(FILSIZ)    DSK

                 DOUBLE PRECISION      VRTCES ( 3, 3 )

                 INTEGER               DLADSC ( DLADSZ )
                 INTEGER               HANDLE
                 INTEGER               I
                 INTEGER               J
                 INTEGER               N
                 INTEGER               NP
                 INTEGER               START
                 INTEGER               VRTIDS ( 3 )

                 LOGICAL               FOUND


           C
           C     Prompt for the name of the DSK to read.
           C
                 CALL PROMPT ( 'Enter DSK name &gt; ', DSK )
           C
           C     Open the DSK file for read access.
           C     We use the DAS-level interface for
           C     this function.
           C
                 CALL DASOPR ( DSK, HANDLE )

           C
           C     Begin a forward search through the
           C     kernel, treating the file as a DLA.
           C     In this example, it's a very short
           C     search.
           C
                 CALL <a href="dlabfs.html">DLABFS</a> ( HANDLE, DLADSC, FOUND )

                 IF ( .NOT. FOUND ) THEN
           C
           C        We arrive here only if the kernel
           C        contains no segments.  This is 
           C        unexpected, but we're prepared for it.
           C
                    CALL <a href="setmsg.html">SETMSG</a> ( 'No segments found '
                .   //            'in DSK file #.'    )
                    CALL <a href="errch.html">ERRCH</a>  ( '#',  DSK           )
                    CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NODATA)'     )

                 END IF

           C
           C     If we made it this far, DLADSC is the
           C     DLA descriptor of the first segment.
           C
           C     Find the number of plates in the model.
           C
                 CALL <b>DSKI02</b> ( HANDLE, DLADSC, KWNP, 1, 1, N, NP )

           C
           C     For each plate, look up the desired data.
           C
                 DO I = 1, NP
           C
           C        For the Ith plate, find the associated 
           C        vertex IDs.  We must take into account
           C        the fact that each plate has three
           C        vertices when we compute the start 
           C        index.
           C
                    START = 3*(I-1)+1

                    CALL <b>DSKI02</b> ( HANDLE, DLADSC, KWPLAT, START, 
                .                 3,      N,      VRTIDS        )

                    DO J = 1, 3
           C
           C            Fetch the vertex associated with
           C            the Jth vertex ID.  Again, each
           C            vertex is a 3-vector.  Note that
           C            the vertices are double-precision
           C            data, so we fetch them using 
           C            <a href="dskd02.html">DSKD02</a>.
           C
                        START = 3*( VRTIDS(J) - 1 ) + 1

                        CALL <a href="dskd02.html">DSKD02</a> ( HANDLE, DLADSC, KWVERT,  START,
                .                     3,      N,      VRTCES(1,J)    )
                    END DO

           C
           C        Display the vertices of the Ith plate:
           C   
                    WRITE (*,*)   ' '
                    WRITE (*,*)   'Plate number: ', I
                    WRITE (*,FMT) '   Vertex 1: ', (VRTCES(J,1), J=1,3)
                    WRITE (*,FMT) '   Vertex 2: ', (VRTCES(J,2), J=1,3)
                    WRITE (*,FMT) '   Vertex 3: ', (VRTCES(J,3), J=1,3)
         
                 END DO

           C
           C     Close the kernel.  This isn't necessary in a stand-
           C     alone program, but it's good practice in subroutines
           C     because it frees program and system resources.
           C
                 CALL <a href="dascls.html">DASCLS</a> ( HANDLE )

                 END


     When this program was executed on a PC/Linux/gfortran/64bit
     platform, using a DSK file representing a regular icosahedron,
     the output was:


      Enter DSK name &gt; solid.bds

       Plate number:            1
          Vertex 1:   0.000000000E+00  0.000000000E+00  0.117557000E+01
          Vertex 2:   0.105146000E+01  0.000000000E+00  0.525731000E+00
          Vertex 3:   0.324920000E+00  0.100000000E+01  0.525731000E+00

       Plate number:            2
          Vertex 1:   0.000000000E+00  0.000000000E+00  0.117557000E+01
          Vertex 2:   0.324920000E+00  0.100000000E+01  0.525731000E+00
          Vertex 3:  -0.850651000E+00  0.618034000E+00  0.525731000E+00

         ...

       Plate number:           20
          Vertex 1:   0.850651000E+00 -0.618034000E+00 -0.525731000E+00
          Vertex 2:   0.000000000E+00  0.000000000E+00 -0.117557000E+01
          Vertex 3:   0.850651000E+00  0.618034000E+00 -0.525731000E+00
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1) This routine uses discovery check-in to boost
        execution speed.  However, this routine is in
        violation of NAIF standards for use of discovery
        check-in:  routines called from this routine may
        signal errors.  If errors are signaled in called
        routines, this routine's name will be missing 
        from the traceback message.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.0, 22-NOV-2016 (NJB)

        Added <a href="failed.html">FAILED</a> check after segment attribute fetch calls.
        Re-ordered code so that values are saved only after
        all error checks have passed. Simplified base address
        comparisons.

     15-JAN-2016 (NJB)

        Updated header Examples and Particulars sections.

     DSKLIB Version 1.0.2, 11-JUL-2014 (NJB)

        Fixed a trivial header comment typo.

     DSKLIB Version 1.0.1, 13-MAY-2010 (NJB)

        Updated header.

     DSKLIB Version 1.0.0, 27-OCT-2006 (NJB)</PRE>
<h4>Link to routine DSKI02 source file <a href='../../../src/spicelib/dski02.f'>dski02.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:46:26 2017</pre>

</body>
</html>

