
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dskxsi</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dskxsi</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
 DSKXSI (DSK, ray-surface intercept with source information)
 
      SUBROUTINE DSKXSI ( PRI,    TARGET, NSURF,  SRFLST, ET,           
     .                    FIXREF, VERTEX, RAYDIR, MAXD,   MAXI,
     .                    XPT,    HANDLE, DLADSC, DSKDSC, DC,     
     .                    IC,     FOUND                        )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Compute a ray-surface intercept using data provided by 
     multiple loaded DSK segments. Return information about 
     the source of the data defining the surface on which the
     intercept was found: DSK handle, DLA and DSK descriptors,
     and DSK data type-dependent parameters.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/ck.html">CK</a>
     <a href="../req/dsk.html">DSK</a>
     <a href="../req/frames.html">FRAMES</a>
     <a href="../req/pck.html">PCK</a>
     <a href="../req/spk.html">SPK</a>
     <a href="../req/time.html">TIME</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     GEOMETRY
     INTERCEPT
     SURFACE
     TOPOGRAPHY
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      IMPLICIT NONE

      INCLUDE 'dsk.inc'
      INCLUDE 'dsktol.inc'    
      INCLUDE 'dsksrc.inc'
      INCLUDE 'srftrn.inc'
      INCLUDE 'zzctr.inc'
        
      LOGICAL               PRI
      CHARACTER*(*)         TARGET
      INTEGER               NSURF
      INTEGER               SRFLST ( * )
      DOUBLE PRECISION      ET
      CHARACTER*(*)         FIXREF
      DOUBLE PRECISION      VERTEX ( 3 )
      DOUBLE PRECISION      RAYDIR ( 3 )
      INTEGER               MAXD
      INTEGER               MAXI
      DOUBLE PRECISION      XPT    ( 3 )
      INTEGER               HANDLE
      INTEGER               DLADSC ( * )
      DOUBLE PRECISION      DSKDSC ( * )
      DOUBLE PRECISION      DC     ( * )
      INTEGER               IC     ( * )
      LOGICAL               FOUND
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     PRI        I   Data prioritization flag. 
     TARGET     I   Target body name.
     NSURF      I   Number of surface IDs in list.
     SRFLST     I   Surface ID list.
     ET         I   Epoch, expressed as seconds past J2000 TDB.
     FIXREF     I   Name of target body-fixed reference frame.
     VERTEX     I   Vertex of ray.
     RAYDIR     I   Direction vector of ray.
     MAXD       I   Size of DC array.
     MAXI       I   Size of IC array.
     XPT        O   Intercept point.
     HANDLE     O   Handle of segment contributing surface data.
     DLADSC     O   DLA descriptor of segment.
     DSKDSC     O   DSK descriptor of segment.
     DC         O   Double precision component of source info.
     IC         O   Integer component of source info.
     FOUND      O   Found flag. 
     DCSIZE     P   Required size of DC array.
     ICSIZE     P   Required size of IC array.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     PRI        is a logical flag indicating whether to perform
                a prioritized or unprioritized DSK segment search.
                In an unprioritized search, no segment masks another:
                data from all specified segments are used to  
                define the surface of interest.

                The search is unprioritized if and only if PRI 
                is set to .FALSE. In the N0066 SPICE Toolkit, this
                is the only allowed value.


     TARGET     is the name of the target body on which a surface
                intercept is sought.


     NSURF,
     SRFLST     are, respectively, a count of surface ID codes in a
                list and an array containing the list. Only DSK
                segments for the body designated by TARGET and having
                surface IDs in this list will be considered in the
                intercept computation. If the list is empty, all DSK
                segments for TARGET will be considered.


     ET         is the epoch of the intersection computation,
                expressed as seconds past J2000 TDB. This epoch is
                used only for DSK segment selection. Segments used in
                the intercept computation must include ET in their
                time coverage intervals.


     FIXREF     is the name of a body-fixed, body-centered reference
                frame associated with the target. The input ray vectors
                are specified in this frame, as is the output intercept
                point.
      
                The frame designated by FIXREF must have a fixed
                orientation relative to the frame of any DSK segment
                used in the computation.


     VERTEX,
     RAYDIR     are, respectively, the vertex and direction vector of
                the ray to be used in the intercept computation. 

                Both the vertex and ray's direction vector must be
                represented in the reference frame designated by
                FIXREF. The vertex is considered to be an offset from
                the target body.
     

     MAXD,
     MAXI       are, respectively, the declared sizes of the arrays
                DC and IC. MAXD must be at least DCSIZE, while
                MAXI must be at least ICSIZE. See the Parameters
                section for details.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     XPT        is the intercept of the input ray on the surface 
                specified by the inputs

                   PRI
                   TARGET
                   NSURF
                   SRFLST
                   ET

                if such an intercept exists. If the ray intersects the
                surface at multiple points, the one closest to the
                ray's vertex is selected.

                XPT is defined if and only if FOUND is .TRUE.

                Units are km.


     HANDLE,
     DLADSC,
     DSKDSK     are, respectively, the DSK file handle, DLA descriptor,
                and DSK descriptor of the DSK file and segment that 
                contributed the surface data on which the intercept 
                was found.

                These outputs are defined if and only if FOUND is
                .TRUE.

     DC,
     IC         are, respectively, double precision and integer arrays
                that may contain additional information associated
                with the segment contributing the surface data on
                which the intercept was found. The information is 
                DSK data type-dependent.

                   For DSK type 2 segments

                      IC(1) is the intercept plate ID.
                      DC is unused.
                  
                These outputs are defined if and only if FOUND is
                .TRUE.

                The declared length of DC must be at least DSIZE;
                the declared length of IC must be at least ISIZE.
                See the Parameter section for details.


     FOUND      is a logical flag that is set to .TRUE. if and only if
                and intercept was found.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     See the include file 

        dsksrc.inc

     for declarations of size parameters

        DCSIZE
        ICSIZE

     for the output arguments

        DC
        IC

     See the include files

        dla.inc
        dskdsc.inc

     for declarations of DLA and DSK descriptor sizes and
     documentation of the contents of these descriptors.

     See the include file

        dsktol.inc

     for the values of tolerance parameters used by default by the
     ray-surface intercept algorithm. These are discussed in in the
     Particulars section below.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If the input prioritization flag PRI is set to .TRUE.,
         the error SPICE(BADPRIORITYSPEC) is signaled.
     
     2)  If the input body name TARGET cannot be mapped to an
         ID code, the error SPICE(IDCODENOTFOUND) is signaled.

     3)  If the input frame name FIXREF cannot be mapped to an
         ID code, the error SPICE(IDCODENOTFOUND) is signaled.

     4)  If the frame center associated with FIXREF cannot be
         retrieved, the error SPICE(NOFRAMEINFO) is signaled.

     5)  If the frame center associated with FIXREF is not
         the target body, the error SPICE(INVALIDFRAME) is signaled.

     6)  If MAXD is less than DCSIZE or MAXI is less than ICSIZE,
         the error SPICE(ARRAYTOOSMALL) will be signaled.

     7)  If NSURF is less than 0, the error SPICE(INVALIDCOUNT)
         is signaled.

     8)  Any errors that occur during the intercept computation
         will be signaled by routines in the call tree of this
         routine.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
    
     Appropriate kernels must be loaded by the calling program before
     this routine is called.

     The following data are required:

        - SPK data: ephemeris data for the positions of the centers
          of DSK reference frames relative to the target body are
          required if those frames are not centered at the target
          body center.

          Typically ephemeris data are made available by loading one
          or more SPK files via <a href="furnsh.html">FURNSH</a>.

        - DSK data: DSK files containing topographic data for the
          target body must be loaded. If a surface list is specified,
          data for at least one of the listed surfaces must be loaded.

        - Frame data: if a frame definition is required to convert
          DSK segment data to the body-fixed frame designated by
          FIXREF, the target, that definition must be available in the
          kernel pool. Typically the definitions of frames not already
          built-in to SPICE are supplied by loading a frame kernel.

        - CK data: if the frame to which FIXREF refers is a CK frame,
          and if any DSK segments used in the computation have a
          different frame, at least one CK file will be needed to
          permit transformation of vectors between that frame and both
          the J2000 and the target body-fixed frames.

        - SCLK data: if a CK file is needed, an associated SCLK
          kernel is required to enable conversion between encoded SCLK
          (used to time-tag CK data) and barycentric dynamical time
          (TDB).

     In all cases, kernel data are normally loaded once per program
     run, NOT every time this routine is called. 
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This is the lowest-level public interface for computing
     ray-surface intercepts, where the surface is modeled using
     topographic data provided by DSK files. The highest-level
     interface for this purpose is <a href="sincpt.html">SINCPT</a>.

     In cases where the data source information returned by this
     routine are not needed, the routine <a href="dskxv.html">DSKXV</a> may be more suitable.

     This routine works with multiple DSK files. It places no
     restrictions on the data types or coordinate systems of the DSK
     segments used in the computation. DSK segments using different
     reference frames may be used in a single computation. The only
     restriction is that any pair of reference frames used directly or
     indirectly are related by a constant rotation.

     This routine enables calling applications to identify the source
     of the data defining the surface on which an intercept was found.
     The file, segment, and segment-specific information such as a DSK
     type 2 plate ID are returned.

     This routine can be used for improved efficiency in situations 
     in which multiple ray-surface intercepts are to be performed
     using a constant ray vertex.


     Using DSK data
     ==============

        DSK loading and unloading
        -------------------------

        DSK files providing data used by this routine are loaded by
        calling <a href="furnsh.html">FURNSH</a> and can be unloaded by calling <a href="unload.html">UNLOAD</a> or
        <a href="kclear.html">KCLEAR</a>. See the documentation of <a href="furnsh.html">FURNSH</a> for limits on numbers
        of loaded DSK files.

        For run-time efficiency, it's desirable to avoid frequent
        loading and unloading of DSK files. When there is a reason to
        use multiple versions of data for a given target body---for
        example, if topographic data at varying resolutions are to be
        used---the surface list can be used to select DSK data to be
        used for a given computation. It is not necessary to unload
        the data that are not to be used. This recommendation presumes
        that DSKs containing different versions of surface data for a
        given body have different surface ID codes.


        DSK data priority
        -----------------

        A DSK coverage overlap occurs when two segments in loaded DSK
        files cover part or all of the same domain---for example, a
        given longitude-latitude rectangle---and when the time
        intervals of the segments overlap as well.

        When DSK data selection is prioritized, in case of a coverage
        overlap, if the two competing segments are in different DSK
        files, the segment in the DSK file loaded last takes
        precedence. If the two segments are in the same file, the
        segment located closer to the end of the file takes
        precedence.

        When DSK data selection is unprioritized, data from competing
        segments are combined. For example, if two competing segments
        both represent a surface as sets of triangular plates, the
        union of those sets of plates is considered to represent the
        surface. 

        Currently only unprioritized data selection is supported.
        Because prioritized data selection may be the default behavior
        in a later version of the routine, the presence of the PRI
        argument is required.


        Round-off errors and mitigating algorithms
        ------------------------------------------

        When topographic data are used to represent the surface of a
        target body, round-off errors can produce some results that
        may seem surprising.

        Note that, since the surface in question might have mountains,
        valleys, and cliffs, the points of intersection found for
        nearly identical sets of inputs may be quite far apart from
        each other: for example, a ray that hits a mountain side in a
        nearly tangent fashion may, on a different host computer, be
        found to miss the mountain and hit a valley floor much farther
        from the observer, or even miss the target altogether.
        
        Round-off errors can affect segment selection: for example, a
        ray that is expected to intersect the target body's surface
        near the boundary between two segments might hit either
        segment, or neither of them; the result may be
        platform-dependent.

        A similar situation exists when a surface is modeled by a set
        of triangular plates, and the ray is expected to intersect the
        surface near a plate boundary.
        
        To avoid having the routine fail to find an intersection when
        one clearly should exist, this routine uses two &quot;greedy&quot;
        algorithms:
       
           1) If the ray passes sufficiently close to any of the 
              boundary surfaces of a segment (for example, surfaces of
              maximum and minimum longitude or latitude), that segment
              is tested for an intersection of the ray with the
              surface represented by the segment's data.

              This choice prevents all of the segments from being
              missed when at least one should be hit, but it could, on
              rare occasions, cause an intersection to be found in a
              segment other than the one that would be found if higher
              precision arithmetic were used.
              
           2) For type 2 segments, which represent surfaces as 
              sets of triangular plates, each plate is expanded very
              slightly before a ray-plate intersection test is
              performed. The default plate expansion factor is 

                 1 + XFRACT

              where XFRACT is declared in 

                 dsktol.inc

              For example, given a value for XFRACT of 1.e-10, the
              sides of the plate are lengthened by 1/10 of a micron
              per km. The expansion keeps the centroid of the plate
              fixed.

              Plate expansion prevents all plates from being missed
              in cases where clearly at least one should be hit.

              As with the greedy segment selection algorithm, plate
              expansion can occasionally cause an intercept to be
              found on a different plate than would be found if higher
              precision arithmetic were used. It also can occasionally
              cause an intersection to be found when the ray misses
              the target by a very small distance. 
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for these examples may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine 
     specific arithmetic implementation. 
      
     1)  Compute surface intercepts of rays emanating from a set of
         vertices distributed on a longitude-latitude grid. All
         vertices are outside the target body, and all rays point
         toward the target's center.

         Check intercepts against expected values. Indicate the
         number of errors, the number of computations, and the
         number of intercepts found.

        Use the meta-kernel below to load example SPICE kernels. 


           KPL/MK

           File: dskxsi_ex1.tm

           This meta-kernel is intended to support operation of SPICE
           example programs. The kernels shown here should not be
           assumed to contain adequate or correct versions of data
           required by SPICE-based user applications.

           In order for an application to use this meta-kernel, the
           kernels referenced here must be present in the user's
           current working directory.

           The names and contents of the kernels referenced
           by this meta-kernel are as follows:

              File name                        Contents
              ---------                        --------
              phobos512.bds                    DSK based on
                                               Gaskell ICQ Q=512
                                               plate model
           \begindata

              PATH_SYMBOLS    = 'GEN'
              PATH_VALUES     = '/ftp/pub/naif/generic_kernels'

              KERNELS_TO_LOAD = ( '$GEN/dsk/phobos/phobos512.bds' )

           \begintext


     Example code begins here.


              PROGRAM SPEAR
              IMPLICIT NONE
        C
        C     Multi-segment spear program.
        C
        C     This program expects all loaded DSKs
        C     to represent the same body and surface.
        C
        C        Syntax: spear &lt;meta-kernel&gt;
        C
        C
              INCLUDE 'dla.inc'
              INCLUDE 'dsk.inc'
              INCLUDE 'dskdsc.inc'
              INCLUDE 'dsksrc.inc'
              INCLUDE 'srftrn.inc'
        C
        C     SPICELIB functions
        C
              DOUBLE PRECISION      <a href="rpd.html">RPD</a>
              DOUBLE PRECISION      <a href="vdist.html">VDIST</a>

              LOGICAL               <a href="failed.html">FAILED</a>
        C
        C     Local parameters
        C
              DOUBLE PRECISION      DTOL
              PARAMETER           ( DTOL   = 1.D-14 )

              INTEGER               BDNMLN
              PARAMETER           ( BDNMLN = 36 )

              INTEGER               FILSIZ
              PARAMETER           ( FILSIZ = 255 )

              INTEGER               FRNMLN
              PARAMETER           ( FRNMLN = 32 )

              INTEGER               TYPLEN
              PARAMETER           ( TYPLEN = 4 )

        C
        C     Local variables
        C
              CHARACTER*(FILSIZ)    DSK1
              CHARACTER*(TYPLEN)    FILTYP
              CHARACTER*(FRNMLN)    FIXREF
              CHARACTER*(FILSIZ)    META
              CHARACTER*(FILSIZ)    SOURCE
              CHARACTER*(BDNMLN)    TARGET

              DOUBLE PRECISION      D
              DOUBLE PRECISION      DC     ( DCSIZE )
              DOUBLE PRECISION      DSKDSC ( DSKDSZ )
              DOUBLE PRECISION      ET
              DOUBLE PRECISION      RAYDIR ( 3 )
              DOUBLE PRECISION      LAT
              DOUBLE PRECISION      LATCRD ( 3 )
              DOUBLE PRECISION      LATSTP
              DOUBLE PRECISION      LON
              DOUBLE PRECISION      LONSTP
              DOUBLE PRECISION      POLMRG
              DOUBLE PRECISION      R
              DOUBLE PRECISION      RADIUS
              DOUBLE PRECISION      VERTEX ( 3 )
              DOUBLE PRECISION      XPT    ( 3 )
              DOUBLE PRECISION      XYZHIT ( 3 )

              INTEGER               BODYID
              INTEGER               DLADSC ( DLADSZ )
              INTEGER               DTYPE
              INTEGER               FRAMID
              INTEGER               HANDLE
              INTEGER               IC     ( ICSIZE )
              INTEGER               NCASES
              INTEGER               NDERR
              INTEGER               NHITS
              INTEGER               NLSTEP
              INTEGER               NSURF
              INTEGER               PLID
              INTEGER               SRFLST ( MAXSRF )
              INTEGER               SURFID

              LOGICAL               FOUND


              CALL CHKIN ( 'SPEAR' )
        C
        C     Load kernel.
        C
              CALL GETCML ( META )

              IF ( META .EQ. ' ' ) THEN
                 CALL <a href="tostdo.html">TOSTDO</a>( 'Syntax: spear &lt;meta-kernel&gt;' )
                 CALL BYEBYE( 'SUCCESS' )
              END IF
        C
        C     Load kernels.
        C
              CALL <a href="furnsh.html">FURNSH</a> ( META )
        C
        C     Get a handle for one of the loaded DSKs,
        C     then find the first segment and extract
        C     the body and surface IDs.
        C
              CALL <a href="kdata.html">KDATA</a>  ( 1,      'DSK',  DSK1, FILTYP,
             .              SOURCE, HANDLE, FOUND )

              CALL <a href="dlabfs.html">DLABFS</a> ( HANDLE, DLADSC, FOUND )

              IF ( .NOT. FOUND ) THEN
                 CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOSEGMENT)' )
              END IF

              CALL <a href="dskgd.html">DSKGD</a> ( HANDLE, DLADSC, DSKDSC )

              BODYID = NINT( DSKDSC(CTRIDX) )
              SURFID = NINT( DSKDSC(SRFIDX) )
              FRAMID = NINT( DSKDSC(FRMIDX) )

              CALL <a href="bodc2n.html">BODC2N</a> ( BODYID, TARGET, FOUND )

              IF ( .NOT. FOUND ) THEN
                 CALL <a href="setmsg.html">SETMSG</a> ( 'Cannot map body ID # to a name.' )
                 CALL <a href="errint.html">ERRINT</a> ( '#',  BODYID                      )
                 CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(BODYNAMENOTFOUND)'         )
              END IF

              CALL <a href="frmnam.html">FRMNAM</a> ( FRAMID, FIXREF )

              IF ( FIXREF .EQ. ' ' ) THEN
                 CALL <a href="setmsg.html">SETMSG</a> ( 'Cannot map frame ID # to a name.' )
                 CALL <a href="errint.html">ERRINT</a> ( '#',  FRAMID                       )
                 CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(FRAMENAMENOTFOUND)'         )
              END IF

        C
        C     Set the magnitude of the ray vertices. Use a large
        C     number to ensure the vertices are outside of
        C     any realistic target.
        C
              R = 1.D10

        C
        C     Spear the target with rays pointing toward
        C     the origin.  Use a grid of ray vertices
        C     located on a sphere enclosing the target.
        C
        C     The variable POLMRG (&quot;pole margin&quot;) can
        C     be set to a small positive value to reduce
        C     the number of intercepts done at the poles.
        C     This may speed up the computation for
        C     the multi-segment case, since rays parallel
        C     to the Z axis will cause all segments converging
        C     at the pole of interest to be tested for an
        C     intersection.
        C
              POLMRG = 5.D-1
              LATSTP = 1.D0
              LONSTP = 2.D0

              NCASES = 0
              NHITS  = 0
              NDERR  = 0

              LON    = -180.D0
              LAT    = 90.D0
              NLSTEP = 0


              WRITE (*,*) 'Computing intercepts...'

              DO WHILE ( LON .LT. 180.D0 )

                 DO WHILE ( NLSTEP .LE. 180  )

                    IF ( LON .EQ. -180.D0 ) THEN

                       LAT = 90.D0 - NLSTEP*LATSTP

                    ELSE

                       IF ( NLSTEP .EQ. 0 ) THEN

                          LAT =  90.D0 - POLMRG

                       ELSE IF ( NLSTEP .EQ. 180 ) THEN

                          LAT = -90.D0 + POLMRG

                       ELSE

                          LAT = 90.D0 - NLSTEP*LATSTP

                       END IF

                    END IF

                    NCASES = NCASES + 1

                    CALL <a href="latrec.html">LATREC</a> ( R, LON*<a href="rpd.html">RPD</a>(), LAT*<a href="rpd.html">RPD</a>(), VERTEX )
                    CALL <a href="vminus.html">VMINUS</a> ( VERTEX, RAYDIR )

                    NSURF     = 1
                    SRFLST(1) = SURFID

                    CALL <b>DSKXSI</b> ( .FALSE., TARGET, NSURF,  SRFLST,
             .                    ET,      FIXREF, VERTEX, RAYDIR,
             .                    DCSIZE,  ICSIZE, XPT,    HANDLE,
             .                    DLADSC, DSKDSC,  DC,     IC,
             .                    FOUND                           )

                    IF ( .NOT. <a href="failed.html">FAILED</a>() .AND. FOUND ) THEN
        C
        C              Record that a new intercept was found.
        C
                       NHITS = NHITS + 1
        C
        C              Compute the latitude and longitude of
        C              the intercept. Make sure these agree
        C              well with those of the vertex.
        C
                       CALL <a href="reclat.html">RECLAT</a> ( XPT,       LATCRD(1),
             .                       LATCRD(2), LATCRD(3) )

                       RADIUS = LATCRD(1)

                       CALL <a href="latrec.html">LATREC</a> ( RADIUS,   LON*<a href="rpd.html">RPD</a>(),
             .                       LAT*<a href="rpd.html">RPD</a>(), XYZHIT    )

                       D = <a href="vdist.html">VDIST</a> ( XPT, XYZHIT )

                       IF ( D/R .GT. DTOL ) THEN
        C
        C                 Get the intercept segment's plate ID if
        C                 applicable.
        C
                          DTYPE = NINT( DSKDSC(TYPIDX) )

                          WRITE (*,*) '======================'
                          WRITE (*,*) 'LON, LAT       = ', LON, LAT
                          WRITE (*,*) 'Bad intercept'
                          WRITE (*,*) 'Distance error = ', D
                          WRITE (*,*) 'XPT            = ', XPT
                          WRITE (*,*) 'XYZHIT         = ', XYZHIT

                          IF ( DTYPE .EQ. 2 ) THEN
                             PLID = IC(1)
                             WRITE (*,*) 'Plate ID      = ', PLID
                          END IF

                          NDERR = NDERR + 1

                       END IF

                    ELSE
        C
        C              Missing the target entirely is a fatal error.
        C
                       WRITE (*,*) '======================'
                       WRITE (*,*) 'LON, LAT = ', LON, LAT
                       WRITE (*,*) 'No intercept'
                       WRITE (*,*) 'NCASES = ', NCASES
                       STOP

                    END IF

                    NLSTEP = NLSTEP + 1

                 END DO

                 LON    = LON + LONSTP
                 LAT    = 90.D0
                 NLSTEP = 0

              END DO

              WRITE (*,*) 'Done.'
              WRITE (*,*) ' '
              WRITE (*,*) 'NCASES = ', NCASES
              WRITE (*,*) 'NHITS  = ', NHITS
              WRITE (*,*) 'NDERR  = ', NDERR
              WRITE (*,*) ' '
              END


     When this program was executed on a PC/Linux/gfortran 64-bit 
     platform, the output was:


        Computing intercepts...
        Done.

        NCASES =        32580
        NHITS  =        32580
        NDERR  =            0
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1)  The frame designated by FIXREF must have a fixed
         orientation relative to the frame of any DSK segment
         used in the computation. This routine has no 
         practical way of ensuring that this condition is met;
         so this responsibility is delegated to the calling
         application.
      
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.0, 04-APR-2017 (NJB) 

        Original 26-FEB-2016 (NJB) </PRE>
<h4>Link to routine DSKXSI source file <a href='../../../src/spicelib/dskxsi.f'>dskxsi.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:46:28 2017</pre>

</body>
</html>

