
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dskmi2</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dskmi2</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
 DSKMI2 ( DSK, make spatial index for type 2 segment )

      SUBROUTINE DSKMI2 ( NV,     VRTCES, NP,     PLATES, FINSCL,
     .                    CORSCL, WORKSZ, VOXPSZ, VOXLSZ, MAKVTL,
     .                    SPXISZ, WORK,   SPAIXD, SPAIXI         ) 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Make spatial index for a DSK type 2 segment. The index is
     returned as a pair of arrays, one of type INTEGER and one of type
     DOUBLE PRECISION. These arrays are suitable for use with the DSK
     type 2 writer <a href="dskw02.html">DSKW02</a>.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/das.html">DAS</a>
     <a href="../req/dsk.html">DSK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     DAS
     DSK
     FILES
     PLATE
     TOPOGRAPHY
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
      IMPLICIT NONE

      INCLUDE 'dskdsc.inc'
      INCLUDE 'dsk02.inc'
      
      INTEGER               NV
      DOUBLE PRECISION      VRTCES ( 3, * )
      INTEGER               NP
      INTEGER               PLATES ( 3, * )
      DOUBLE PRECISION      FINSCL
      INTEGER               CORSCL
      INTEGER               WORKSZ
      INTEGER               VOXPSZ
      INTEGER               VOXLSZ
      LOGICAL               MAKVTL
      INTEGER               SPXISZ
      INTEGER               WORK   ( 2, WORKSZ )
      DOUBLE PRECISION      SPAIXD ( IXDFIX )
      INTEGER               SPAIXI ( SPXISZ )
      
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Description
     --------  ---  --------------------------------------------------
     IXDFIX     P   Size of fixed-size portion of d.p. index component.
     IXIFIX     P   Size of fixed-size portion of integer index 
                    component.
     NV         I   Number of vertices.
     VRTCES     I   Vertices.
     NP         I   Number of plates.
     PLATES     I   Plates.
     FINSCL     I   Fine voxel scale.
     CORSCL     I   Coarse voxel scale.
     WORKSZ     I   Workspace size.
     VOXPSZ     I   Voxel-plate pointer array size.
     VOXLSZ     I   Voxel-plate list array size.
     MAKVTL     I   Vertex-plate list flag.
     SPXISZ     I   Spatial index integer component size.
     WORK       I   Workspace.
     SPAIXD     I   Double precision component of spatial index.
     SPAIXI     I   Integer component of spatial index.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     NV          is the number of vertices belonging to the input
                 set of plates.

 
     VRTCES      is an array of coordinates of the vertices. The Ith
                 vertex occupies elements (1:3,I) of this array.


     NP          is the number of plates in the input plate set.


     PLATES      is an array representing the triangular plates of a
                 shape model. The elements of PLATES are vertex
                 indices; vertex indices are 1-based. The vertex
                 indices of the Ith plate occupy elements (1:3,I) of
                 this array.


     FINSCL      is the fine voxel scale. This scale determines the
                 edge length of the cubical voxels comprising the fine
                 voxel grid: the edge length VOXSIZ is approximately
                 
                     FINSCL * {average plate extent}

                 where the extents of a plate are the respective
                 differences between the maximum and minimum
                 coordinate values of the plate's vertices.
                 
                 The relationship between VOXSIZ and the average plate
                 extent is approximate because the VOXSIZ is adjusted
                 so that each dimension of the fine voxel grid is an
                 integer multiple of the coarse voxel scale.

                 See the Particulars section below for further 
                 information on voxel scales.
      
     
     CORSCL      is the coarse voxel scale. This integer scale is the 
                 ratio of the edge length of coarse voxels to
                 that of fine voxels. The coarse scale must be
                 large enough so that the total number of coarse
                 voxels does not exceed MAXCGR (see the Parameters
                 section below).


     WORKSZ      is the second dimension of the workspace array WORK.
                 WORKSZ must be at least as large as the greater of
                 
                    - the number of fine voxel-plate associations

                      This number is equal to

                         NP * {average number of fine voxels 
                               intersected by each plate}

                    - the number of vertex-plate associations, if
                      the vertex-plate mapping is constructed.
 
                      This number is equal to

                         NV + ( 3 * NP )
                      

     VOXPSZ      is the size of the fine voxel-plate pointer array.
                 This array maps fine voxels to lists of plates that
                 intersect those voxels. VOXPSZ must be at least as
                 large as

                          3
                    CORSCL  * {number of non-empty coarse voxels}


     VOXLSZ      is the size of the fine voxel-plate list array. This
                 array contains, for each non-empty fine voxel, the
                 count of plates that intersect that voxel and the
                 IDs of those plates. VOXLSZ must be at least as large
                 as

                         NP * {average number of fine voxels 
                               intersected by each plate}
                    
                     +   {number of non-empty fine voxels}


     MAKVTL      is a logical flag that, when set to .TRUE., indicates
                 that a  vertex-plate association list is to be
                 constructed.

                 The amount of workspace that is needed may depend on
                 whether a vertex-plate association list is
                 constructed. When this list is constructed, the size
                 of the integer component of the spatial index is
                 increased by the size of the list and the size of a
                 vertex-plate pointer array; the total of these sizes
                 is

                    ( 2 * NV ) + ( 3 * NP )


     SPXISZ      is the declared size of the output array SPAIXI. This
                 size must be at least as large as the sum of

                    - the fixed-size part of the integer component of
                      the index, which includes the coarse voxel grid;
                      this value is 

                         IXIFIX

                    - the size VOXPSZ of the voxel-plate pointer array

                    - the size VOXLSZ of the voxel-plate association
                      list
      
                 plus, if the vertex-plate association list is
                 constructed,

                    - the size NV of the vertex-plate pointer array
       
                    - the size of the vertex-plate association list; 
                      this size is

                         NV + ( 3 * NP )
                 
                  
     WORK        is the workspace array. The array should be declared
                 with dimensions

                    (2, WORKSZ)

                 See the description of WORKSZ above.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     WORK        is the workspace array, modified by the operations
                 performed by this routine.

     SPAIXD,
     SPAIXI      are, respectively, the double precision and integer
                 components of the spatial index of the segment.

                 SPAIXD must be declared with size at least IXDFIX.
                 SPAIXI must be declared with size at least SPXISZ.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     IXDFIX      is the size of the double precision component of
                 the spatial index.

     IXIFIX      is the size of the fixed-size portion of the integer
                 component of the spatial index.

     See the include file dsk02.inc for declarations of the public DSK
     type 2 parameters used by this routine.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If the fine voxel scale is non-positive, the error
         SPICE(BADFINEVOXELSCALE) is signaled.

     2)  If the coarse voxel scale is less than 1, the error
         SPICE(BADCOARSEVOXSCALE) is signaled.

     3)  If NV is less than 3 or greater than MAXVRT, the error
         SPICE(BADVERTEXCOUNT) is signaled.

     4)  If NP is less than 1 or greater than MAXPLT, the error
         SPICE(BADPLATECOUNT) is signaled.

     5)  If the workspace size WORKSZ is less than NP+1, the error
         SPICE(WORKSPACETOOSMALL) is signaled. This is merely a 
         sanity check; normally the workspace will need to be 
         substantially larger than this reference value. See the 
         description of WORKSZ in the header section Detailed_Input
         above.

     6)  If the voxel-plate pointer array size VOXPSZ is less than 1,
         the error SPICE(PTRARRAYTOOSMALL) is signaled. This is merely
         a sanity check; normally this pointer array will need to be
         substantially larger than this reference value. See the
         description of VOXPSZ in the header section Detailed_Input
         above.

     7)  If the voxel-plate list array size VOXLSZ is less than NP+1,
         the error SPICE(PLATELISTTOOSMALL) is signaled. This is
         merely a sanity check; normally this array will need to be
         substantially larger than this reference value. See the
         description of VOXLSZ in the header section Detailed_Input
         above.

     8)  If the size SPXISZ of the integer array SPAIXI is too small
         to contain its constituent structures, where the sizes
         of these structures are derived from the inputs

             NV, NP, VOXPSZ, VOXLSZ
             
         the error SPICE(INTINDEXTOOSMALL) will be signaled.

     9)  If there is insufficient room to create any of the data
         structures contained in the spatial index, the error
         will be diagnosed and signaled by a routine in the call
         tree of this routine.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     Users planning to create DSK files should consider whether the 
     SPICE DSK creation utility MKDSK may be suitable for their needs.

     This routine supports use of the DSK type 2 segment writer <a href="dskw02.html">DSKW02</a>
     by creating the &quot;spatial index&quot; arrays required as inputs to that
     routine.

     A spatial index is a group of data structures that facilitates
     rapid high-level computations involving sets of plates. The data
     structures created by this routine are aggregated into arrays
     of type INTEGER and type DOUBLE PRECISION. 


     Voxel grids
     ===========

     A key geometric computation---probably the most important, as it
     serves as a foundation for other high-level computations---is
     finding the intersection of a ray with the plate set. DSK type 2
     segments use data structures called &quot;voxel grids&quot; as part of
     their indexing mechanism. There is a &quot;coarse grid&quot;: a box that
     completely encloses a DSK type 2 segment's plate set, and which
     is composed of identically-sized cubes called &quot;coarse voxels.&quot;
     Each coarse voxel in composed of smaller cubes called &quot;fine
     voxels.&quot; When the term &quot;voxel&quot; is used without qualification, it
     refers to fine voxels.

     Type 2 DSK segments contain data structures that associate plates
     with the fine voxels intersected by those plates. These
     structures enable the type 2 DSK software to rapidly find plates
     in a given region of space.

     Voxel scales
     ============
     
     There are two voxel scales:

        - The coarse voxel scale is the integer ratio of the
          edge length of a coarse voxel to the edge length of
          a fine voxel

        - The fine voxel scale is the double precision ratio
          of the edge length of a fine voxel to the average
          extent of the plates in the input plate set. &quot;Extents&quot;
          of a plate are the absolute values of the differences 
          between the respective maximum and minimum X, Y, and Z
          coordinates of the plate's vertices.

     Voxel scales determine the resolution of the voxel grid. 
     Voxel scales must be chosen to satisfy size constraints and
     provide reasonable plate lookup performance.

     The following considerations apply to spatial indexes of
     type 2 DSK segments:

        1)  The maximum number of coarse voxels is fixed at MAXCGR
            (declared in dsk02.inc).

        2)  If there are too few fine voxels, the average number of
            plates per fine voxel will be very large. This largely
            negates the performance improvement afforded by having an
            index. Also, the number of plates per voxel may exceed
            limits imposed by DSK subroutines that use static arrays.

        3)  If there are too many fine voxels, the average number of
            voxels intersected by a given plate may be too large for
            all the plate-voxel associations to be stored. In
            addition, the time needed to examine the plate lists for
            each voxel (including the empty ones) may become quite
            large, again negating the value of the index.
          
     In many cases, voxel scales yielding optimum performance must be
     determined by experiment. However, the following heuristics can
     provide reasonable starting values:

        Let NP be the number of plates. Let FS be the fine voxel
        scale. Then a reasonable value of FS may be

                   (0.25D0)
           FS =  NP       / 8.D0

        In general, FS should not smaller than 1.
        
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for this example may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine 
     specific arithmetic implementation. 

     1) Create a three-segment DSK file using plate model data for
        Phobos. Use latitudinal, rectangular, and planetodetic
        coordinates in the respective segments. This is not a 
        realistic example, but it serves to demonstrate use of 
        the supported coordinate systems.

        For simplicity, use an existing DSK file to provide the 
        input plate and vertex data. The selected input file has one
        segment.


     C
     C     Example program for <a href="dskw02.html">DSKW02</a>, <b>DSKMI2</b>, and <a href="dskrb2.html">DSKRB2</a>
     C
     C        Create a three-segment DSK file using plate model data
     C        for Phobos. Use latitudinal, rectangular, and
     C        planetodetic coordinates in the respective segments.
     C
     C        For simplicity, use an existing DSK file to provide the
     C        input plate and vertex data. The selected input file has
     C        one segment.
     C
     C           Version 1.0.0 22-JAN-2016 (NJB)
     C
           PROGRAM EX1
           IMPLICIT NONE

           INCLUDE 'dla.inc'
           INCLUDE 'dskdsc.inc'
           INCLUDE 'dsk02.inc'

     C
     C     SPICELIB functions
     C
           DOUBLE PRECISION      <a href="jyear.html">JYEAR</a>
           DOUBLE PRECISION      <a href="pi.html">PI</a>
     C
     C     Local parameters
     C
           INTEGER               FRNMLN
           PARAMETER           ( FRNMLN = 32 )

           INTEGER               NSEG
           PARAMETER           ( NSEG   = 3 )

           INTEGER               NAMLEN
           PARAMETER           ( NAMLEN = 20 )

           INTEGER               FILSIZ
           PARAMETER           ( FILSIZ = 255 )

           INTEGER               LNSIZE
           PARAMETER           ( LNSIZE = 80 )

           INTEGER               NCOR
           PARAMETER           ( NCOR   = 4 )

     C
     C     Local variables
     C
           CHARACTER*(NAMLEN)    CORNAM ( NCOR )
           CHARACTER*(FILSIZ)    DSK
           CHARACTER*(FRNMLN)    FRAME
           CHARACTER*(FILSIZ)    INDSK
           CHARACTER*(LNSIZE)    LINE
     C
     C     Note: the values of MAXVRT and MAXPLT declared
     C     in dsk02.inc, and the integer spatial index
     C     dimension SPAISZ are very large. Smaller buffers
     C     can be used for most applications.
     C
           DOUBLE PRECISION      CORPAR ( NSYPAR )
           DOUBLE PRECISION      F
           DOUBLE PRECISION      FINSCL
           DOUBLE PRECISION      FIRST
           DOUBLE PRECISION      LAST
           DOUBLE PRECISION      MNCOR1
           DOUBLE PRECISION      MNCOR2
           DOUBLE PRECISION      MNCOR3
           DOUBLE PRECISION      MXCOR1
           DOUBLE PRECISION      MXCOR2
           DOUBLE PRECISION      MXCOR3
           DOUBLE PRECISION      RE
           DOUBLE PRECISION      RP
           DOUBLE PRECISION      SPAIXD ( IXDFIX )
           DOUBLE PRECISION      VRTCES ( 3, MAXVRT )

           INTEGER               CENTER
           INTEGER               CORSCL
           INTEGER               CORSYS
           INTEGER               DCLASS
           INTEGER               DLADSC ( DLADSZ )
           INTEGER               HANDLE
           INTEGER               INHAN
           INTEGER               NP
           INTEGER               NV
           INTEGER               PLATES ( 3, MAXPLT )
           INTEGER               SEGNO
           INTEGER               SPAIXI ( SPAISZ )
           INTEGER               SURFID
           INTEGER               VOXPSZ
           INTEGER               VOXLSZ
           INTEGER               WORK   ( 2, MAXCEL )
           INTEGER               WORKSZ

           LOGICAL               FOUND
     C
     C     Saved variables
     C
     C     Save all large arrays to avoid stack problems.
     C
           SAVE
     C
     C     Initial values
     C
           DATA                  CORNAM / 'radius',
          .                               'Z-coordinate',
          .                               'Z-coordinate',
          .                               'altitude'     /

     C
     C     Assign names of input and output DSK files.
     C
           INDSK = 'phobos_3_3.bds'
           DSK   = 'phobos_3_3_3seg.bds'
     C
     C     Open input DSK for read access; find first segment.
     C
           CALL DASOPR ( INDSK, INHAN )
           CALL <a href="dlabfs.html">DLABFS</a> ( INHAN, DLADSC, FOUND )
     C
     C     Fetch vertices and plates from input DSK file.
     C
           WRITE (*,*) 'Reading input data...'

           CALL <a href="dskv02.html">DSKV02</a> ( INHAN, DLADSC, 1, MAXVRT, NV, VRTCES )
           CALL <a href="dskp02.html">DSKP02</a> ( INHAN, DLADSC, 1, MAXPLT, NP, PLATES )

           WRITE (*,*) 'Done.'
     C
     C     Set input array sizes required by <b>DSKMI2</b>.
     C
           VOXPSZ = MAXVXP
           VOXLSZ = MXNVLS
           WORKSZ = MAXCEL
     C
     C     Set fine and coarse voxel scales. (These usually
     C     need to determined by experimentation.)
     C
           FINSCL = 5.D0
           CORSCL = 4
     C
     C     Open a new DSK file.
     C
           CALL <a href="dskopn.html">DSKOPN</a> ( DSK, DSK, 0, HANDLE )
     C
     C     Create three segments and add them to the file.
     C
           DO SEGNO = 1, NSEG
     C
     C        Create spatial index.
     C
              WRITE (*,*) 'Creating segment ', SEGNO
              WRITE (*,*) 'Creating spatial index...'

              CALL <b>DSKMI2</b> ( NV,     VRTCES, NP,     PLATES, FINSCL,
          .                 CORSCL, WORKSZ, VOXPSZ, VOXLSZ, .TRUE.,
          .                 SPAISZ, WORK,   SPAIXD, SPAIXI          )

              WRITE (*,*) 'Done.'
     C
     C        Set up inputs describing segment attributes:
     C
     C        - Central body: Phobos
     C        - Surface ID code: user's choice.
     C          We use the segment number here.
     C        - Data class: general (arbitrary) shape
     C        - Body-fixed reference frame
     C        - Time coverage bounds (TBD)
     C
              CENTER = 401
              SURFID = SEGNO
              DCLASS = GENCLS
              FRAME  = 'IAU_PHOBOS'

              FIRST = -50 * <a href="jyear.html">JYEAR</a>()
              LAST  =  50 * <a href="jyear.html">JYEAR</a>()
     C
     C        Set the coordinate system and coordinate system
     C        bounds based on the segment index.
     C
     C        Zero out the coordinate parameters to start.
     C
              CALL <a href="cleard.html">CLEARD</a> ( NSYPAR, CORPAR )

              IF ( SEGNO .EQ. 1 ) THEN
     C
     C           Use planetocentric latitudinal coordinates. Set
     C           the longitude and latitude bounds.
     C
                 CORSYS = LATSYS

                 MNCOR1 = -<a href="pi.html">PI</a>()
                 MXCOR1 =  <a href="pi.html">PI</a>()
                 MNCOR2 = -<a href="pi.html">PI</a>()/2
                 MXCOR2 =  <a href="pi.html">PI</a>()/2

              ELSE IF ( SEGNO .EQ. 2 ) THEN
     C
     C           Use rectangular coordinates. Set the
     C           X and Y bounds.
     C
     C           The bounds shown here were derived from
     C           the plate data. They lie slightly outside
     C           of the range spanned by the plates.
     C
                 CORSYS = RECSYS

                 MNCOR1 = -1.3D0
                 MXCOR1 =  1.31D0
                 MNCOR2 = -1.21D0
                 MXCOR2 =  1.2D0

              ELSE
     C
     C           Set the coordinate system to planetodetic.
     C
                 CORSYS    = PDTSYS

                 MNCOR1    = -<a href="pi.html">PI</a>()
                 MXCOR1    =  <a href="pi.html">PI</a>()
                 MNCOR2    = -<a href="pi.html">PI</a>()/2
                 MXCOR2    =  <a href="pi.html">PI</a>()/2
     C
     C           We'll use equatorial and polar radii from
     C           pck00010.tpc. These normally would be fetched
     C           at run time, but for simplicity, we'll use
     C           hard-coded values.

                 RE        = 13.0D0
                 RP        =  9.1D0
                 F         = ( RE - RP ) / RE

                 CORPAR(1) = RE
                 CORPAR(2) = F

              END IF
     C
     C        Compute plate model radius bounds.
     C
              LINE = 'Computing # bounds of plate set...'

              CALL <a href="repmc.html">REPMC</a> ( LINE, '#', CORNAM(CORSYS), LINE )
              WRITE (*,*) LINE

              CALL <a href="dskrb2.html">DSKRB2</a> ( NV,     VRTCES, NP,     PLATES,
          .                 CORSYS, CORPAR, MNCOR3, MXCOR3 )

              WRITE (*,*) 'Done.'
     C
     C        Write the segment to the file.
     C
              WRITE (*,*) 'Writing segment...'

              CALL <a href="dskw02.html">DSKW02</a> ( HANDLE,
          .                 CENTER, SURFID, DCLASS, FRAME,  CORSYS,
          .                 CORPAR, MNCOR1, MXCOR1, MNCOR2, MXCOR2,
          .                 MNCOR3, MXCOR3, FIRST,  LAST,   NV,
          .                 VRTCES, NP,     PLATES, SPAIXD, SPAIXI )

              WRITE (*,*) 'Done.'

           END DO
     C
     C     Segregate the data records in the DSK file and
     C     close the file.
     C
           WRITE (*,*) 'Segregating and closing DSK file...'

           CALL <a href="dskcls.html">DSKCLS</a> ( HANDLE, .TRUE. )

           WRITE (*,*) 'Done.'
           END


     
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.0, 13-DEC-2016 (NJB)

        Updated check on NV.

        16-MAR-2016 (NJB)

        Now zeros out the size of the vertex-plate list
        when the list is not created.

        23-JAN-2016 (NJB)

           Original version.</PRE>
<h4>Link to routine DSKMI2 source file <a href='../../../src/spicelib/dskmi2.f'>dskmi2.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:46:26 2017</pre>

</body>
</html>

